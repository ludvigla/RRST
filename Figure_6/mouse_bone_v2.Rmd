---
title: "Mouse bone tissue analysis"
author: "Ludvig Larsson"
date: "2/28/2022"
output: 
  html_document:
    theme: flatly
    toc: true
    toc_depth: 3
    toc_float: true
    code_folding: show
---

<style type="text/css">
div.main-container {
  background-color: #FFFFFF !important;
  max-width: 1800px !important;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Preparation
***

Load required R packages. If you want more information about [STUtility](https://github.com/jbergenstrahle/STUtility), you can visit my website: https://ludvigla.github.io/STUtility_web_site/

```{r warning=FALSE, message=FALSE}

library(STutility)
library(magrittr)
library(dplyr)
library(harmony)
library(zeallot)
library(swne)

```

First we need to assemble the required spaceranger output files: expression matrices, H&E images, spot position table and scale factors.

Then we can load our files into a `Seurat` object with the `InputFromTable` function.

```{r eval=FALSE}

samples <- list.files(path = "../../spaceranger_output/bone", pattern = "filtered", recursive = TRUE, full.names = TRUE)
imgs <- list.files(path = "../../spaceranger_output/bone", pattern = "tissue_hires_image.png", recursive = TRUE, full.names = TRUE)
spotfiles <- list.files(path = "../../spaceranger_output/bone", pattern = "tissue_positions_list.csv", recursive = TRUE, full.names = TRUE)
json <- list.files(path = "../../spaceranger_output/bone", pattern = "scalefactors_json.json", recursive = TRUE, full.names = TRUE)

infoTable <- data.frame(samples = samples, imgs = imgs, spotfiles = spotfiles, json = json, 
                        arrayID = c("V11D08-324_A1", "V11D08-324_B1", "V11D08-324_C1", "V11D08-324_D1"),
                        condition = c("RNA rescue", "RNA rescue", "RNA rescue", "RNA rescue"),
                        age = c("postnatal day 4", "postnatal day 4", "postnatal day 11", "postnatal day 11"))

se <- InputFromTable(infoTable)

```

## Sequencing metrics
***

Provides an overview of some basic stats generated by spaceranger. For example, it is always good to check that the sequencing saturation is high, which seems to be the case for these samples!

```{r}

metrics <- list.files(path = "../../spaceranger_output/bone", pattern = "metrics_summary.csv", recursive = TRUE, full.names = TRUE)
do.call(plyr::rbind.fill, lapply(metrics[3:6], function(f) read.csv(f, check.names = FALSE))) %>%
  DT::datatable(options = list(scrollX = TRUE))

```

## H&E
***

Before we can visualize expression data on the H&E images, we need to load the images into our `Seurat` object with the `LoadImages` function.

```{r eval=FALSE}

se <- LoadImages(se, time.resolve = TRUE)

```

```{r include=FALSE}

se <- readRDS("R_objects/mBone_Seurat_object_raw")

```

And then we can visualize the H&E images with `ImagePlot`.

```{r fig.width=6, fig.height=6, out.width="100%"}

ImagePlot(se, type = "raw")

```

Below I have manually selected spots overlaying the bone/cartilage tissue (based on visual inspection) that we can use later on.

```{r fig.width=8, fig.height=8}

# se <- ManualAnnotation(se)
#se <- SubsetSTData(se, spots = rownames(subset(se[[]], labels %in% "bone")))

#saveRDS(colnames(se)[se$labels == "bone"], file = "../../spaceranger_output/bone/mm_bone_selected_spots")
selected.spots <- readRDS("../../spaceranger_output/bone/mm_bone_selected_spots")
#se <- SubsetSTData(se, spots = selected.spots)
se$bone_selection <- "other"
se@meta.data[selected.spots, "bone_selection"] <- "bone"

ST.FeaturePlot(se, features = "bone_selection", ncol = 2, label.by = "day_rep", show.sb = FALSE)

```


## Quality Control (QC)
***

### Violin pots
***

The plots below provide an overview of the number of unique genes and the number of UMIs. Note that the y-axis has been log10-transformed. These metrics are typically used for quality control and filtering. Setting filtering thresholds is not always straightforward and depend on the tissue type. The easiest way to decide on a threshold is to base it on the distribution of unique genes per spot.

Below we can see that the mean number of unique genes is 2118 across all fours tissue sections, and the mean number of UMIs is 6199 across all four tissue sections. 

```{r}

p <- ggplot(se@meta.data, aes(area, nFeature_RNA, fill = "mouse bone")) + 
  labs(x = "", y = "", title = "RNA rescue on mouse bone/cartilage: unique genes", fill = "", x = "Visium ID") +
  geom_violin(scale = "width") +
  geom_jitter(size = 0.1) +
  geom_hline(data = se@meta.data %>% 
               summarize(Mean = mean(nFeature_RNA)), aes(yintercept = Mean), linetype = "longdash") +
  geom_label(data = se@meta.data %>% 
               summarize(Mean = round(mean(nFeature_RNA))), aes("A", Mean, label = Mean),
             show.legend = FALSE) +
  scale_y_log10() +
  scale_x_discrete(labels = c("", "postnatal day 4 - Rep1", "postnatal day 4 - Rep2", "postnatal day 11 - Rep1", "postnatal day 11 - Rep2")) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 60, hjust = 1), legend.position = "none")
p


p <- ggplot(se@meta.data, aes(area, nCount_RNA, fill = "mouse bone")) + 
  labs(x = "", y = "", title = "RNA rescue on mouse bone/cartilage: unique genes", fill = "", x = "Visium ID") +
  geom_violin(scale = "width") +
  geom_jitter(size = 0.1) +
  geom_hline(data = se@meta.data %>% 
               summarize(Mean = mean(nCount_RNA)), aes(yintercept = Mean), linetype = "longdash") +
  geom_label(data = se@meta.data %>% 
               summarize(Mean = round(mean(nCount_RNA))), aes("A", Mean, label = Mean),
             show.legend = FALSE) +
  scale_y_log10() +
  scale_x_discrete(labels = c("", "postnatal day 4 - Rep1", "postnatal day 4 - Rep2", "postnatal day 11 - Rep1", "postnatal day 11 - Rep2")) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 60, hjust = 1), legend.position = "none")
p

```

### Spatial pots
***

We can also visualize the same metrics as a "spatial heatmap", where each spot is colored by the number of unique genes or UMIs. This is also good for QC to determine if certain regions are missing data or if we observe any technical artefacts.

```{r fig.width=8, fig.height=10}

se$day_rep <- paste0(se$age, " - ", ifelse(GetStaffli(se)@meta.data$sample %in% c(1, 3), "Rep1", "Rep2"))

p <- FeatureOverlay(se, features = "nFeature_RNA", ncols = 2, pt.size = 1.3, sampleids = 1:4,
                    label.by = "day_rep", show.sb = FALSE, value.scale = c(0, max(se$nFeature_RNA)),
                    cols = c("darkblue", "cyan", "yellow", "red", "darkred")) & 
  theme(legend.position = "top", legend.text = element_text(angle = 30, hjust = 1), plot.title = element_blank()) &
  labs(fill = "unique genes")

p

p <- FeatureOverlay(se, features = "nCount_RNA", ncols = 2, pt.size = 1.3, sampleids = 1:4,
                    label.by = "day_rep", show.sb = FALSE, value.scale = c(0, max(se$nCount_RNA)),
                    cols = c("darkblue", "cyan", "yellow", "red", "darkred")) & 
  theme(legend.position = "top", legend.text = element_text(angle = 30, hjust = 1), plot.title = element_blank()) &
  labs(fill = "number of molecules")

p

```

From these plots we can see that parts of the tissue sections are more or less empty and we should remove these spots before proceeding with downstream analysis.

We can determine a cutoff threshold based on the plots above or a simple histogram (I selected 500 as a threshold):

```{r}

ggplot(se[[]], aes(nFeature_RNA)) +
  geom_histogram(bins = 50) +
  geom_vline(xintercept = 500)

```

Spots with lower than ~500 unique genes are likely empty due to tissue detachment, lack of cells or failure to permeabilize the tissue.

```{r fig.width=8, fig.height=8}

se$spots_to_remove <- ifelse(se$nFeature_RNA < 500, "remove", "keep")
ST.FeaturePlot(se, features = "spots_to_remove", ncol = 2, label.by = "day_rep", show.sb = FALSE)

table(se$spots_to_remove)

```

With this threshold, we will remove 248 spots which gives us 6981 spots left to use for downstream analysis.

```{r include=FALSE}

se.filtered <- readRDS("R_objects/mBone_Seurat_object_filtered")

```


```{r eval=FALSE}

se.filtered <- SubsetSTData(se, expression = nFeature_RNA > 500)

```

Normalize data using `SCTransform`.

```{r eval=FALSE}

se.filtered <- SCTransform(se.filtered)

```

# Analysis
***

## Proliferating cells
***

Since this tissue contain a lot of proliferating cells, I thought it could be interesting to estimate cell cycle scores from the gene expression data.

One way to do this is to use the cell cycle genes provided with the `Seurat` R package:

```{r eval=FALSE}

m.s.genes <- setdiff(read.csv(file = "../../sheets/ss_genes.csv")$ortholog_name, "N/A")
m.g2m.genes <- setdiff(read.csv(file = "../../sheets/g2m_genes.csv")$ortholog_name, "N/A")

```

```{r eval=FALSE}

se.filtered <- CellCycleScoring(se.filtered, s.features = m.s.genes, g2m.features = m.g2m.genes)

```

### Visualization of cell cycle score
***

In the plot below we can see clearly that the S and G2M phase scores are enriched in the mineralizing bone and cartilage, in particular for postnatal day 4 indicating that cells are proliferating in this region.

```{r fig.width=9, fig.height=8.5, out.width="100%"}

FeatureOverlay(se.filtered, features = "S.Score", cols = c("darkblue", "cyan", "yellow", "red", "darkred"), 
               add.alpha = TRUE, label.by = "day_rep", sampleids = 1:4, ncols = 2, value.scale = "all", pt.size = 1.3)

FeatureOverlay(se.filtered, features = "G2M.Score", cols = c("darkblue", "cyan", "yellow", "red", "darkred"), 
               add.alpha = TRUE, label.by = "day_rep", sampleids = 1:4, ncols = 2, value.scale = "all", pt.size = 1.3)

```


## Matrix factorization
***

Non-negative Matrix Factorization (NNMF) is useful as an exploratory tool to identify transcriptional programs in Visium data.

In brief, the gene expression matrix (`A`) is decomposed into matrices `W` and `H`:

* `A` : expression matrix genes x spots
* `W` : genes x factors
* `H` : factors x spots

where the number of factors (k) is a predefined value. The constraint for non-negativity makes it easier to interpret the factors as compared to e.g. Principal Component Analysis. Rows in `W` provide a measure of the relative contribution of genes to each factors which makes it possible to obtain biological insights. On the other hand, columns in `H` measure the relative contribution of spots to each factor which makes it possible to visualize where in the tissue the factors are active.

The interpretation of what a factor represents is not crystal clear, but it usually pick up relevant sources of biological variation in the tissue data. A factor could for example correspond to a cell type, two co-localized cell types or a biological pathway. This can however be extremely useful, especially when there is no scRNA-seq data available to conduct cell type mapping with. 

```{r eval=FALSE}

se.filtered <- STutility::RunNMF(se.filtered, nfactors = 30)

```

### NNMF results {.tabset}
***

```{r functions, include=FALSE}
catHeader <- function(text = "", level = 4) {
    cat(paste0("\n\n", 
               paste(rep("#", level), collapse = ""), 
               " ", text, "\n"))
}
```

Visualize factors and their corresponding top gene drivers.

```{r}

plots <- lapply(1:30, function(i) {
  p1 <- FeatureOverlay(se.filtered, features = paste0("factor_", i), sampleids = 1:4, center.zero = FALSE, label.by = "day_rep", value.scale = "all",
                   cols = c("darkblue", "cyan", "yellow", "red", "darkred"), ncols = 2, show.sb = FALSE, pt.size = 1, add.alpha = T)
  p2 <- FactorGeneLoadingPlot(se.filtered, factor = i, topn = 40)
  cowplot::plot_grid(p1, p2, ncol = 2, rel_widths = c(3, 2))
})

```

You can go through the factors one by one by clicking on the tabs to see their spatial distribution and their top 40 driving genes. We can already see a couple of things:

NOTE: I tried to follow the annotations shared by Phillip but I realize that many of the observations below are likely a bit misinterpreted :-)

* factor 1 : mineralizing cartilage and bone related (closer to cartilage), contains some hypertrophic chondrocyte markers as well as those for bone formation
* factor 2 : present in the cartilage but is much more prominent at postnatal day 11
* factor 3 : correspond to blood vessels (erythrocytes) and appear to be most prominent at postnatal day 4 in mineralizing cartilage and bone
' factor 4 : look like it is localized in perichondrium and synovium at postnatal day 4
' factor 5 : localized in synovium(?) at postnatal day 4 but beneath factor 4
' factor 6 : localized in synovium(?) at postnatal day 4 and 11, same place as factor 4. P: This factor appears to be localised in the cruciate ligament. It is very highly expressed there in comparison with surrounding synovium.
' factor 7 : localized at the edges of cartilage and bone. Judging by the markers Col16a1 and Tnn, most likely fibroblasts? P: Perhaps, there is such clear spatial expression pattern on the surface of the cartilage and bone, so can also be periosteum/perichondrium.  
* factor 8 : muscle related factor present at postnatal day 11
* factor 9 : adipose tissue [Adipoq, Plin1, Fabp4]
*. factor 10 : nerve fibers? Got many hits for Schwann cells ... P: Incredibly powerful to be able to be able to locate them
*. factor 11 : localized in mineralizing cartilage and bone + SOC at postnatal day 4 and 11. Macrophage/fibroblast?
*. factor 12 : localized in cartilage at postnatal day 4 and 11. Looks a bit patchy between replicates, potential technical effect ... This factor likely represent chondrocytes? [Col2a1, Col9a1, Col9a3, Col9a2, Snorc, Acan]. P: Yes, could the patchiness be explained by the relatively low number of reads per spot according to the QC?
* factor 13 : muscle-related and present at postnatal day 4 and 11
* factor 14 : Myocyte-related, more prominent at postnatal day 11
* factor 15 : Unknown, looks a bit patchy between replicates. Potential technical effect.
* factor 16 : localized in mineralizing cartilage and bone at postnatal day 4 and 11. Osteoblast related? [Bglap]. P: Yes, this is wonderful! These are osteoblasts: BGLAP (Bone Gla protein), SPP1 (Osteopontin), Col1a1, Col1a2 (comprising type-1 collagen, the most abundant protein in bone tissue) and it also contains osteocyte markers (the cells that osteoblasts differentiate into within the bone matrix, such as Sost and DMP1 (which is also used as a late-osteoblast marker).
* factor 17 : localized in mineralizing cartilage and bone and more prominent at postnatal day 4. Slighlty different spatial location in day 4 vs day 11. P: Perhaps cells of the bone marrow?
* factor 18 : Unknown, looks a bit patchy between replicates. Potential technical effect.
* factor 19 : muscle-related and more prominent at postnatal day 4
* factor 20 : Unknown, but distinct spatial location in muscle tissue
* factor 21 : Fibroblasts
* factor 22 : Unknown 
* factor 23 : Unknown, looks a bit patchy between replicates. Potential technical effect.
* factor 24 : Fibroblast/myocyte related?
* factor 25 : Unknown
* factor 26 : Unknown, but distinct spatial location
* factor 27 : localized in mineralizing cartilage and bone + SOC at postnatal day 4 and 11. P: Not really sure what cells this factor represents.
* factor 28 : localized in synovium(?) and surrounding cartilage at postnatal day 4 and 11 (upper part). Chondrocyte/fibroblast? P: Looks like articular cartilage/surface by localisation, but lacks some markers in the gene list.
* factor 29 : Fibroblast-related, noisy
* factor 30 : Unknown, but distinct spatial location. More prominent at postnatal day 4.

```{r results = "asis", echo = FALSE, fig.width=14, fig.height=8.5, out.width="100%"}

for(i in seq_along(plots)){
    catHeader(paste0("factor_", 1:30)[i], 4)
    plots[[i]] %>% print()
}

```

### {-}

We can also obtain a quick heatmap overview of the top driving genes per factor:

```{r fig.width=8, fig.height=14}

c(df1, df2) %<-% STutility::SummarizeAssocFeatures(se.filtered, features.return = 4)

ggHeat(df2[nrow(df2):1, ], rescaling = "column") +
  scale_fill_gradientn(colours = viridis::magma(n = 11, direction = -1))

```

### Layering of bone
***

Below I have a visualization of some of the factors localized on the bone/cartilage. The dominant factor in each spot determines the color, so this plot makes it possible to appreciate the layering of the bone.

I excluded the cartilage factor_12 in this plot because it was a bit too dominant.

```{r fig.width=9, fig.height=4, out.width="100%"}

HSVOverlay(se.filtered, features = paste0("factor_", c(1, 2, 5, 11, 16, 17, 27, 28)), pt.size = 1.3,
           add.alpha = T, sampleids = c(1, 4), ncols.samples = 2, sample.label = FALSE, show.sb = FALSE)



```

And here are the top 10 driving genes for each of the selected factors.

```{r fig.width=8, fig.height=14}

c(df1, df2) %<-% STutility::SummarizeAssocFeatures(se.filtered, features.return = 10, 
                                                   dims = c(1, 2, 5, 11, 16, 17, 27, 28))

ggHeat(df2[nrow(df2):1, ], rescaling = "column") +
  scale_fill_gradientn(colours = viridis::magma(n = 11, direction = -1))

```


NOTE: In the analysis above, I've just used 30 factors, but it is possible that some of them are redundant or that it makes more sense to decompose the data into even more factors. 

## Clustering + DEA
***

We can also resort to more basic analyses such as unsupervised clustering and DEA. However, we need to remember that spot profiles are mixed and dividing the data based on unsupervised clustering is often somewhat arbitrary in contrast to scRNA-seq where we have discrete populations of cells.

Most of the signal you can get from clustering + DEA, you can get directly from the factor analysis, but clusters are perhaps easier to interpret.

### Clustering
***

```{r eval=FALSE}

se.filtered <- se.filtered %>%
  RunPCA() %>%
  FindNeighbors(reduction = "pca", dims = 1:30) %>%
  FindClusters() %>%
  RunUMAP(reduction = "pca", dims = 1:30)
se.filtered$seurat_clusters_pca <- se.filtered$seurat_clusters

```

In the UMAP embedding below, I have colored the spots by `cluster`, `age` and `area`. We can see that the there are some clear batch effects in the data, as the spots separate based on the capture area ID. 

For a clustering analysis, I think it makes most sense to analyze the two time points separately since they are so different. If we do this, we can also try to correct for the batch effects between replicates.

```{r fig.width=16, fig.height=5}

p1 <- DimPlot(se.filtered, group.by = "seurat_clusters_pca", label = TRUE, reduction = "umap")
p2 <- DimPlot(se.filtered, group.by = "age", label = TRUE, reduction = "umap")
p3 <- DimPlot(se.filtered, group.by = "area", label = TRUE, reduction = "umap")

(p1 | p2 | p3) + patchwork::plot_layout(ncol = 3)

```

### data integration [age]
***

We can also integrate the data across the two time points. Because we saw already that there's a separation between different slides, we can either correct for both "area" and "age" or "area" only. Below I have included both "age" or "area" as group variables when running harmony.

```{r eval=FALSE}

#se.filtered <- readRDS("R_objects/mBone_Seurat_object_filtered")

se.filtered <- se.filtered %>% 
  RunHarmony(group.by.vars = c("area", "age"), reduction = "pca", dims.use = 1:30, assay.use = "SCT") %>%
  FindNeighbors(reduction = "harmony", dims = 1:30) %>%
  FindClusters() %>%
  RunUMAP(reduction = "harmony", dims = 1:30, reduction.name = "umap.harmony")

se.filtered$seurat_clusters_harmony <- se.filtered$seurat_clusters

```

After data integration we can see that many of the clusters are now shared across time points.

```{r fig.width=16, fig.height=5}

p1 <- DimPlot(se.filtered, group.by = "seurat_clusters_harmony", label = TRUE, reduction = "umap.harmony")
p2 <- DimPlot(se.filtered, group.by = "age", label = TRUE, reduction = "umap.harmony")
p3 <- DimPlot(se.filtered, group.by = "area", label = TRUE, reduction = "umap.harmony")

(p1 | p2 | p3) + patchwork::plot_layout(ncol = 3)

```

```{r fig.width=9, fig.height=9, out.width="100%"}

ST.FeaturePlot(se.filtered, features = "seurat_clusters_harmony", label.by = "day_rep", ncol = 2, show.sb = FALSE, pt.size = 1.3)

```

### DEA
***

Now we can run a DEA to extract marker genes for each cluster. 

```{r include=FALSE}
 de.markers.all.data <- readRDS(file = "R_objects/de.markers.all.data")
```

Re-scale data before plotting. This is to make sure that also genes with lower variability can be included.

```{r eval=FALSE}

DefaultAssay(se.filtered) <- "RNA"
se.filtered <- se.filtered %>% NormalizeData() %>% ScaleData() %>% FindVariableFeatures()

```

Now we can apply `FindAllMarkers` to extract marker genes for each cluster.

```{r eval=FALSE}

de.markers.all.data <- FindAllMarkers(se.filtered, only.pos = TRUE, logfc.threshold = 0.25, max.cells.per.ident = 50)

```

#### DE heatmap
***

```{r include=FALSE}
DefaultAssay(se.filtered) <- "RNA"
```


```{r fig.width=11, fig.height=15}

DoHeatmap(se.filtered, features = de.markers.all.data %>% 
          group_by(cluster) %>% 
          filter(p_val_adj < 0.01) %>%
          slice_head(n = 10) %>% 
          pull(gene))

```

#### DE table
***

```{r}

de.markers.all.data %>% 
  mutate(cluster = paste0("cluster_", cluster), 
         p_val_adj = format(p_val_adj, digits = 3), 
         p_val = format(p_val, digits = 3), 
         avg_log2FC = format(avg_log2FC, digits = 3)) %>%
  DT::datatable()

```

```{r eval=FALSE, include=FALSE}
DefaultAssay(se.filtered) <- "SCT"
```

### Sub-clustering of [cartilage only]
***

```{r include=FALSE}
se.filtered.bone <- readRDS("R_objects/mBone_Seurat_object_filtered_bone")
```


```{r eval=FALSE}

# Read annotations
ann.files <- list.files("../../sheets/bone_annotations", full.names = TRUE)
annotations <- do.call(rbind, lapply(seq_along(ann.files), function(i) {
  f <- ann.files[i]
  ann <- read.csv(f, check.names = FALSE)
  rownames(ann) <- paste0(ann$Barcode, "_", i)
  ann$section_id <- i
  return(ann)
}))

annotations <- annotations %>% mutate(labels = case_when(`mouse growth plate` == "hypertrophic" ~ "hypertrophic zone",
                                                         `mouse growth plate` == "pre-Hypertrophic" ~ "pre-Hypertrophic zone",
                                          `mouse growth plate` == "proliferative" ~ "proliferative zone",
                                          `mouse growth plate` == "resting" ~ "resting zone",
                                          TRUE ~ `mouse growth plate`))

se.filtered.bone$annotation <- annotations[colnames(se.filtered.bone), "labels"]
se.filtered.bone <- SubsetSTData(se.filtered.bone, expression = annotation != "")

```

Plot selections

```{r fig.width=14, fig.height=12}

cols <- setNames(c("#332288", "#88CCEE", "#44AA99", "#117733", "#DDCC77", "#CC6677","#AA4499"), 
                 nm = c("articular cartilage", "hypertrophic zone", "pre-Hypertrophic zone", "proliferative zone", 
                        "resting zone", "SOC", "SOC-adjacent resting zone"))
se.filtered.bone$day_rep <- paste0(se.filtered.bone$age, "_", se.filtered.bone$area)
FeatureOverlay(se.filtered.bone, features = "annotation", ncol = 2, label.by = "day_rep", sampleids = 1:4, cols = cols)

```

I threw in a new plot here showing the number of unique genes per spot in each of the data sets and region. As you can see, there's some variability in quality, in particular within the pre-Hypertrophic, hypertrophic and proliferative zones. 

```{r fig.width=16, fig.height=6}

se.filtered.bone[[]] %>%
  ggplot(aes(day_rep, nFeature_RNA, fill = day_rep)) +
    geom_violin(scale = "width") +
    geom_jitter() +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 12), axis.text.y = element_text(size = 12)) +
    labs(y = "", title = "nFeature_RNA") +
    facet_grid(~annotation)

```



```{r include=FALSE}
se.filtered.bone <- readRDS("R_objects/mBone_Seurat_object_filtered_bone")
```

Normalize data, run dimensionality reduction by PCA + data integration by harmony and data-.driven clustering of the cartilage spots.

```{r eval=FALSE}

se.filtered.bone <- se.filtered.bone %>%
  SCTransform() %>%
  RunPCA() %>%
  RunHarmony(group.by.vars = c("area", "age"), reduction = "pca", dims.use = 1:30, assay.use = "SCT")

```

```{r fig.width=12, fig.height=5, eval=FALSE}

plots <- lapply(1:30, function(i) {
  p1 <- ST.DimPlot(se.filtered.bone, dims = i, reduction = "harmony", ncol = 2, 
                 cols = RColorBrewer::brewer.pal(n = 11, name = "RdBu") %>% rev(), 
                 show.sb = FALSE, label.by = "day_rep")
  p2 <- DimHeatmap(se.filtered.bone, dims = i, raster = FALSE, fast = FALSE)
  
  p <- p1 | p2
  return(p)
})

plots[[2]]

```
Here I have selected a smaller number of components to use as basis for clustering. I checked the components 7, 8, 9, ... and these components have such low contribution that they can be omitted.

```{r eval=FALSE}

DefaultAssay(se.filtered.bone) <- "SCT"
se.filtered.bone <- se.filtered.bone %>%
  FindNeighbors(reduction = "harmony", dims = 1:6, k.param = 20) %>%
  FindClusters(resolution = 0.8) %>%
  RunUMAP(reduction = "harmony", dims = 1:6, reduction.name = "umap.harmony")
se.filtered.bone$seurat_clusters_harmony <- se.filtered.bone$seurat_clusters

```


From the plot below, it seems like the manually selected zones overlay with clusters only to some extent.

```{r fig.width=12, fig.height=10}

p1 <- DimPlot(se.filtered.bone, group.by = "seurat_clusters_harmony", label = TRUE, reduction = "umap.harmony")
p2 <- DimPlot(se.filtered.bone, group.by = "age", reduction = "umap.harmony")
p3 <- DimPlot(se.filtered.bone, group.by = "area", reduction = "umap.harmony")
p4 <- DimPlot(se.filtered.bone, group.by = "annotation", reduction = "umap.harmony")

(p1 + p2 + p3 + p4) + patchwork::plot_layout(ncol = 2)

```

We can also try to visualize the overlap between manually selected groups of spots with the data-driven clusters:

```{r}

se.filtered.bone[[]] %>%
  group_by(annotation, seurat_clusters) %>%
  summarize(Freq = n()) %>%
  group_by(annotation) %>%
  mutate(Freq = Freq/sum(Freq)) %>%
  ggplot(aes(annotation, Freq, fill = seurat_clusters)) +
    geom_bar(stat = "identity") +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 60, hjust = 1))

```

Seurat clusters for all four tissue sections (cartilage selection only).

NOTE: It still appears as if the expected zones still appear to be split into multiple clusters. I'm not sure how we can mitigate this issue with the sub-clustering analysis, but we can explore the matrix factorization as an alternative option.

```{r fig.width=9, fig.height=9, out.width="100%"}

ST.FeaturePlot(se.filtered.bone, features = "seurat_clusters_harmony", label.by = "day_rep", ncol = 2, show.sb = FALSE, pt.size = 1.3)

```

Seurat clusters [split view] for all four tissue sections (cartilage selection only).

```{r fig.width=6, fig.height=20, out.width="100%"}

p1 <- cowplot::plot_grid(plotlist = lapply(levels(se.filtered.bone$seurat_clusters_harmony), function(cl) {
  FeatureOverlay(se.filtered.bone, features = "seurat_clusters_harmony", label.by = "day_rep", sampleids = 1,
               ncol = 1, show.sb = FALSE, pt.size = 0.7, spots = rownames(subset(se.filtered.bone[[]], seurat_clusters_harmony %in% cl))) &
    labs(subtitle = paste0("cluster ", cl, " : postnatal day 11_V11D08-324_C1")) &
    theme(legend.position = "none", plot.title = element_blank())
}), ncol = 1)
p2 <- cowplot::plot_grid(plotlist = lapply(levels(se.filtered.bone$seurat_clusters_harmony), function(cl) {
  FeatureOverlay(se.filtered.bone, features = "seurat_clusters_harmony", label.by = "day_rep", sampleids = 4,
               ncol = 1, show.sb = FALSE, pt.size = 0.7, spots = rownames(subset(se.filtered.bone[[]], seurat_clusters_harmony %in% cl))) &
    labs(subtitle = paste0("cluster ", cl, " : postnatal day 4_V11D08-324_B1")) &
    theme(legend.position = "none", plot.title = element_blank())
}), ncol = 1)

p1 | p2

```

#### RGB plot [cartilage only]
***

```{r eval=FALSE}

se.filtered.bone <- se.filtered.bone %>%
  RunUMAP(reduction = "harmony", dims = 1:6, reduction.name = "umap.3d", n.components = 3)

```

There is still a significant separation between the upper and lower part (green) that appears to align with the "leakage" factor that we observed earlier. 

```{r fig.width=10, fig.height=10}

ST.DimPlot(se.filtered.bone, dims = 1:3, reduction = "umap.3d", ncol = 2, show.sb = FALSE, dark.theme = TRUE, blend = TRUE)

```


#### Cell cycle scoring
***

These scores do not look very specific to me. Quite a few of the cell cycle genes are not even present in the data, so maybe a different set of genes would be more useful.

```{r}

m.s.genes <- setdiff(read.csv(file = "../../sheets/ss_genes.csv")$ortholog_name, "N/A")
m.g2m.genes <- setdiff(read.csv(file = "../../sheets/g2m_genes.csv")$ortholog_name, "N/A")

se.filtered.bone <- CellCycleScoring(se.filtered.bone, s.features = m.s.genes, g2m.features = m.g2m.genes)

```

```{r fig.width=9, fig.height=4.5, out.width="100%"}

FeatureOverlay(se.filtered.bone, features = "S.Score", cols = c("darkblue", "cyan", "yellow", "red", "darkred"), ncol = 2, label.by = "day_rep", sampleids = c(1, 4), pt.size = 1)
FeatureOverlay(se.filtered.bone, features = "G2M.Score", cols = c("darkblue", "cyan", "yellow", "red", "darkred"), ncol = 2, label.by = "day_rep", sampleids = c(1, 4), pt.size = 1)
FeatureOverlay(se.filtered.bone, features = "Phase", ncol = 2, label.by = "day_rep", sampleids = c(1, 4), pt.size = 1)

```

#### Chondrocyte markers  {.tabset}
***

Expression of selected markers. Prg4 is not present in the data.

I realize that the expression of these markers is quite sparse. Maybe if we had more markers per type (e.g. hypertrophic/SOC, resting, ...) we could estimate a joint score which would circumvent the issue with sparsity. 

```{r fig.width=9, fig.height=12, out.width="100%"}

selected.markers <- c("Col10a1", "Pthlh", "Foxa2", "Ucma", "Ihh")
for(i in seq_along(selected.markers)){
    catHeader(selected.markers[i], 5)
    p <- ST.FeaturePlot(se.filtered.bone, features = selected.markers[i], cols = c("darkblue", "cyan", "yellow", "red", "darkred"), ncol = 2, label.by = "day_rep") +
      VlnPlot(se.filtered.bone, features = selected.markers[i]) +
      patchwork::plot_layout(nrow = 2, heights = c(2, 1)) 
    p %>% print()
}

```

#### {-}


#### DEA [cartilage only manually annotated zones]
***

Below is a DE analysis on the manually selected regions. As we could see previously, these selections do not appear to correlate with the data-driven clusters very well. However, it could be informative to run a DEA on groups selected using a completely orthogonal data type.

```{r include=FALSE}
de.markers.all.data.bone.annotations <- readRDS(file = "R_objects/de.markers.all.data.bone.annotations")
```

Re-scale data before plotting. This is to make sure that also genes with lower variability can be included.

```{r}

DefaultAssay(se.filtered.bone) <- "RNA"
se.filtered.bone <- SetIdent(se.filtered.bone, value = se.filtered.bone$annotation)
se.filtered.bone <- se.filtered.bone %>% NormalizeData() %>% ScaleData() %>% FindVariableFeatures()

```

Now we can apply `FindAllMarkers` to extract marker genes for each cluster.

```{r eval=FALSE}

de.markers.all.data.bone.annotations <- FindAllMarkers(se.filtered.bone, only.pos = TRUE, logfc.threshold = 0.25)

```

#### DE heatmap [cartilage only manually annotated zones]
***

```{r include=FALSE}
DefaultAssay(se.filtered.bone) <- "RNA"
```


```{r fig.width=11, fig.height=15}

DoHeatmap(se.filtered.bone, features = de.markers.all.data.bone.annotations %>% 
          group_by(cluster) %>% 
          filter(p_val_adj < 0.01) %>%
          slice_head(n = 10) %>% 
          pull(gene))

```

#### DE table [cartilage only manually annotated zones]
***

```{r}

de.markers.all.data.bone.annotations %>% 
  mutate(p_val_adj = format(p_val_adj, digits = 3), 
         p_val = format(p_val, digits = 3), 
         avg_log2FC = format(avg_log2FC, digits = 3)) %>%
  DT::datatable()

```

#### DEA [cartilage only sub-clustering]
***

Now we can run a DEA to extract marker genes for each cluster. 

```{r include=FALSE}
de.markers.all.data.bone <- readRDS(file = "R_objects/de.markers.all.data.bone")
```

Now we can apply `FindAllMarkers` to extract marker genes for each cluster.

```{r eval=FALSE}

se.filtered.bone <- SetIdent(se.filtered.bone, value = "seurat_clusters")
de.markers.all.data.bone <- FindAllMarkers(se.filtered.bone, only.pos = TRUE, logfc.threshold = 0.25)

```

#### DE heatmap
***

```{r include=FALSE}
DefaultAssay(se.filtered.bone) <- "RNA"
```


```{r fig.width=11, fig.height=15}

se.filtered.bone <- SetIdent(se.filtered.bone, value = se.filtered.bone$seurat_clusters_harmony)
DoHeatmap(se.filtered.bone, features = de.markers.all.data.bone %>% 
          group_by(cluster) %>% 
          filter(p_val_adj < 0.01) %>%
          slice_head(n = 10) %>% 
          pull(gene))

```

#### DE table
***

```{r}

de.markers.all.data.bone %>% 
  mutate(cluster = paste0("cluster_", cluster), 
         p_val_adj = format(p_val_adj, digits = 3), 
         p_val = format(p_val, digits = 3), 
         avg_log2FC = format(avg_log2FC, digits = 3)) %>%
  DT::datatable()

```

### Matrix factorization [cartilage only] {.tabset}
***

One potential explanation for the relatively poor overlap between the data-driven clustering and the manually selected regions is that there's leakage of transcripts from surrounding tissues. We could run a matrix factorization to see if we can separate such effects.

The matrix factorization procedure might also be more effective at picking up interesting signals from the cartilage tissue.

NOTE: Below I have set k = 10 for the factor analysis. 

```{r eval=FALSE}

DefaultAssay(se.filtered.bone) <- "SCT"
se.filtered.bone <- se.filtered.bone %>%
  STutility::RunNMF(nfactors = 10)

```

Visualize factors and their corresponding top gene drivers.

```{r}

plots <- lapply(1:10, function(i) {
  p1 <- FeatureOverlay(se.filtered.bone, features = paste0("factor_", i), sampleids = 1:4, 
                       center.zero = FALSE, label.by = "day_rep", value.scale = "all",
                   cols = c("darkblue", "cyan", "yellow", "red", "darkred"), ncols = 2, 
                   show.sb = FALSE, pt.size = 1, add.alpha = T)
  p2 <- FactorGeneLoadingPlot(se.filtered.bone, factor = i, topn = 40)
  cowplot::plot_grid(p1, p2, ncol = 2, rel_widths = c(3, 2))
})

```

NOTE: I made a mistake in the previous notebook so the top contributing genes were actually incorrect as they were taken from the previous factor analysis. Should be correct now.

I tried a bunch of different things to handle this "leakage" effect, but it appears to be quite difficult. We have a couple of alternative IMO that we can go for:

1. Try to identify the genes that contribute to the leakage and remove those. This is tricky because I'm not sure exactly what to look for.
2. Focus on the factor analysis results that we have, either for the whole data set or cartilage only. If we can be confident that the "leakage" patterns are picked up by certain factors, we could just motivate that these represent a contamination from the surrounding tissue and then we focus on the factors that do make sense.
3. We could also skip the data-driven analyses completely and look at the DEA results for the manually selected region. This was we might not be able to detect any new regions, but perhaps we could identify markers that have not been described in literature before. 
4. If you have lists of known markers, we could use these to compute joint estimates (module scores). This could be useful as a proof of concept to show that we can define known regions based on molecular markers. However, 1 marker per region does not suffice. We need at least a few of them per region.

```{r results = "asis", echo = FALSE, fig.width=14, fig.height=8.5, out.width="100%"}

for(i in seq_along(plots)){
    catHeader(paste0("factor_", 1:10)[i], 4)
    plots[[i]] %>% print()
}

```

### {-}


## Split data and rerun analysis
***

For the purpose of batch correction (between capture areas), we'll use harmony. 

```{r include = FALSE}
se.filtered.split <- readRDS("R_objects/mBone_Seurat_object_filtered_list")
```

```{r eval=FALSE}

se.filtered.split <- lapply(unique(se.filtered$age), function(day) {
  se.filtered.subset <- SubsetSTData(se.filtered, expression = age %in% day) %>%
    SCTransform() %>%
    RunPCA() %>%
    RunHarmony(group.by.vars = "area", reduction = "pca", dims.use = 1:30, assay.use = "SCT") %>%
    FindNeighbors(reduction = "harmony", dims = 1:30) %>%
    FindClusters() %>%
    RunUMAP(reduction = "harmony", dims = 1:30, reduction.name = "umap.harmony")
  return(se.filtered.subset)
})

```


Now we can see the effects of data integration by harmony. The data is now evenly mixed between capture areas, indicating that the integration method has managed to harmonize the data in low dimensional space.

I also added a plot showing the manual selection of spots localized on the bone tissue. Based on this, it seems like mainly clusters 0, 3, 8 and 10 (also parts of 2 and 4) are bone related at postnatal day 4 and cluster 2, 4 and 7 are bone related at postnatal day 11 (also parts of 6 and 8).

```{r fig.width=19, fig.height=5, out.width="100%"}

se.filtered.split <- lapply(se.filtered.split, function(se) {
  se$annotation <- ifelse(se$annotation == "", "background", se$annotation)
  return(se)
})

p1 <- DimPlot(se.filtered.split[[1]], reduction = "umap.harmony", group.by = "seurat_clusters", label = TRUE) + 
  ggtitle("Clustering of integrated day 4 data") + 
  theme(plot.title = element_text(size = 12))
p2 <- DimPlot(se.filtered.split[[1]], reduction = "umap.harmony", group.by = "annotation", label = TRUE) + 
  ggtitle("Clustering of integrated day 4 data") + 
  theme(plot.title = element_text(size = 12))
p3 <- DimPlot(se.filtered.split[[1]], reduction = "umap.harmony", group.by = "area") + 
  ggtitle("Integrated day 4 data colored by capture area") + 
  theme(plot.title = element_text(size = 12))
p1 | p2 | p3

p1 <- DimPlot(se.filtered.split[[2]], reduction = "umap.harmony", group.by = "seurat_clusters", label = TRUE) + 
  ggtitle("Clustering of integrated day 11 data") + 
  theme(plot.title = element_text(size = 12))
p2 <- DimPlot(se.filtered.split[[2]], reduction = "umap.harmony", group.by = "annotation", label = TRUE) + 
  ggtitle("Clustering of integrated day 11 data") + 
  theme(plot.title = element_text(size = 12))
p3 <- DimPlot(se.filtered.split[[2]], reduction = "umap.harmony", group.by = "area") + 
  ggtitle("Integrated day 11 data colored by capture area") + 
  theme(plot.title = element_text(size = 12))
p1 | p2 | p3

```

## RGB plot
***

Another way of visualizing the heterogeneity of the the data after integration is to color code each spot. One way to do this is to project the expression data into 3 UMAP dimensions, transform these vectors into a unit cube and use these scaled values as color channels in RGB space.

```{r eval = FALSE}

se.filtered.split <- lapply(se.filtered.split, function(se) {
  se <- se %>% RunUMAP(reduction = "harmony", dims = 1:30, reduction.name = "umap.3d", n.components = 3)
  return(se)
})

```

In the plot below, each color represent a distinct expression profile. Here it is easy to appreciate gradual changes in expression between different regions.

```{r fig.width=9, fig.height=4.5, out.width="100%"}

ST.DimPlot(se.filtered.split[[1]], dims = 1:3, reduction = "umap.3d", blend = TRUE, pt.size = 1.5, show.sb = FALSE, dark.theme = TRUE)
ST.DimPlot(se.filtered.split[[2]], dims = 1:3, reduction = "umap.3d", blend = TRUE, pt.size = 1.5, show.sb = FALSE, dark.theme = TRUE)

```

### Spatial distribution of clusters
***

Let's have a look at how the clusters are distributed on the tissue.

```{r fig.width=8, fig.height=9, out.width="100%"}

p1 <- ST.FeaturePlot(se.filtered.split[[1]], features = "seurat_clusters", label.by = "area", show.sb = FALSE) &
  labs(title = "Clusters : postnatal day 4")
p2 <- ST.FeaturePlot(se.filtered.split[[2]], features = "seurat_clusters", label.by = "area", show.sb = FALSE) &
  labs(title = "Clusters : postnatal day 11")

p1 | p2

```

### Spatial distribution of clusters [split view]
***

We can also split the view to look at one cluster at the time which makes it slightly easier to distinguish them from each other.

```{r fig.width=10, fig.height=11, out.width="100%"}

ST.FeaturePlot(se.filtered.split[[1]], features = "seurat_clusters", label.by = "area", show.sb = FALSE, indices = 1, split.labels = TRUE, ncol = 4, pt.size = 1.3) &
  labs(title = "Clusters [split view] : postnatal day 4")

```

```{r fig.width=10, fig.height=11, out.width="100%"}

ST.FeaturePlot(se.filtered.split[[2]], features = "seurat_clusters", label.by = "area", show.sb = FALSE, indices = 2, split.labels = TRUE, ncol = 4, pt.size = 1.3) &
  labs(title = "Clusters [split view] : postnatal day 11")

```


## Differential Expression Analysis (DEA)
***

Now we can run a DEA to extract marker genes for each cluster. 

```{r include=FALSE}
de.markers <- readRDS(file = "R_objects/de.markers")
```

Rescale data before plotting. This is to make sure that also genes with lower variability can be included.

```{r eval=FALSE}

se.filtered.split <- lapply(se.filtered.split, function(se) {
  DefaultAssay(se) <- "RNA"
  se <- se %>% NormalizeData() %>% ScaleData() %>% FindVariableFeatures()
  return(se)
})

```

Now we can apply `FindAllMarkers` to extract marker genes for each cluster.

```{r eval=FALSE}

de.markers <- lapply(se.filtered.split, function(se.subset) {
  des <- FindAllMarkers(se.subset, only.pos = TRUE, logfc.threshold = 0.25, max.cells.per.ident = 50)
  return(des)
})

```

### Postnatal day 4 DEA
***

```{r fig.width=11, fig.height=15}

DoHeatmap(se.filtered.split[[1]], features = de.markers[[1]] %>% 
          group_by(cluster) %>% 
          filter(p_val_adj < 0.01) %>%
          slice_head(n = 10) %>% 
          pull(gene))

```

Tabular view of DE genes for postnatal day 4

```{r}

de.markers[[1]] %>% 
  mutate(cluster = paste0("cluster_", cluster), 
         p_val_adj = format(p_val_adj, digits = 3), 
         p_val = format(p_val, digits = 3), 
         avg_log2FC = format(avg_log2FC, digits = 3)) %>%
  DT::datatable()

```
### Postnatal day 11 DEA
***

```{r fig.width=11, fig.height=15}

DoHeatmap(se.filtered.split[[2]], features = de.markers[[2]] %>% 
          group_by(cluster) %>% 
          filter(p_val_adj < 0.01) %>%
          slice_head(n = 10) %>% 
          pull(gene))

```

Tabular view of DE genes for postnatal day 11

```{r}

de.markers[[2]] %>% 
  mutate(cluster = paste0("cluster_", cluster), 
         p_val_adj = format(p_val_adj, digits = 3), 
         p_val = format(p_val, digits = 3), 
         avg_log2FC = format(avg_log2FC, digits = 3)) %>%
  DT::datatable()

```
### Example DE markers
***

```{r fig.width=8, fig.height=20, out.width="100%"}

FeatureOverlay(se.filtered, features = c("Col6a1", "Clec3a", "Mbp", "Tagln", "Csrp3"), ncol = 2, label.by = "day_rep", 
               sampleids = c(1, 4), layout.by.feature = FALSE, show.sb = FALSE, pt.size = 1.3,
               cols = c("darkblue", "cyan", "yellow", "red", "darkred"), add.alpha = TRUE, value.scale = "all")

```

## Sub-clustersing
***

We can also try to further divide the bone and cartilage associated clusters by performing sub-clustering. Below I have used all spots manually annotated as bone/cartilage.

```{r include=FALSE}
se.filtered.split.bone <- readRDS("R_objects/mBone_Seurat_object_filtered_list_bone")
```

```{r eval=FALSE}

se.filtered.split.bone <- lapply(se.filtered.split, function(se) {
  se <- se %>% SubsetSTData(expression = bone_selection == "bone") %>%
    SCTransform() %>%
    RunPCA() %>%
    RunHarmony(group.by.vars = "area", reduction = "pca", dims.use = 1:30, assay.use = "SCT") %>%
    FindNeighbors(reduction = "harmony", dims = 1:30) %>%
    FindClusters() %>%
    RunUMAP(reduction = "harmony", dims = 1:30, reduction.name = "umap.harmony")
  return(se)
})

```

```{r fig.width=12, fig.height=5, out.width="100%"}

p1 <- DimPlot(se.filtered.split.bone[[1]], reduction = "umap.harmony", group.by = "seurat_clusters", label = TRUE) + 
  ggtitle("Clustering of integrated day 4 data") + 
  theme(plot.title = element_text(size = 12))
p2 <- DimPlot(se.filtered.split.bone[[1]], reduction = "umap.harmony", group.by = "area") + 
  ggtitle("Integrated day 4 data colored by capture area") + 
  theme(plot.title = element_text(size = 12))
p1 | p2

p1 <- DimPlot(se.filtered.split.bone[[2]], reduction = "umap.harmony", group.by = "seurat_clusters", label = TRUE) + 
  ggtitle("Clustering of integrated day 11 data") + 
  theme(plot.title = element_text(size = 12))
p2 <- DimPlot(se.filtered.split.bone[[2]], reduction = "umap.harmony", group.by = "area") + 
  ggtitle("Integrated day 11 data colored by capture area") + 
  theme(plot.title = element_text(size = 12))
p1 | p2

```
 
Spatial distribution of bone/cartilage sub-clusters

```{r fig.width=11, fig.height=5, out.width="100%"}

FeatureOverlay(se.filtered.split.bone[[1]], features = "seurat_clusters", pt.size = 1.3,
               sampleids = 1:2, ncols = 2, show.sb = FALSE, label.by = "day_rep")

FeatureOverlay(se.filtered.split.bone[[2]], features = "seurat_clusters", pt.size = 1.3,
               sampleids = 1:2, ncols = 2, show.sb = FALSE, label.by = "day_rep")

```

 
And just like before, we can apply `FindAllMarkers` to extract marker genes for each sub-cluster.

```{r}
de.markers.sub <- readRDS("R_objects/de.markers.sub")
```


```{r eval=FALSE}

de.markers.sub <- lapply(se.filtered.split.bone, function(se.subset) {
  des <- FindAllMarkers(se.subset, only.pos = TRUE, logfc.threshold = 0.25, max.cells.per.ident = 50)
  return(des)
})

```
 
### Postnatal day 4 DEA - sub-clusters
***

```{r fig.width=11, fig.height=15}

DoHeatmap(se.filtered.split.bone[[1]], features = de.markers.sub[[1]] %>% 
          group_by(cluster) %>% 
          filter(p_val_adj < 0.01) %>%
          slice_head(n = 10) %>% 
          pull(gene))

```

Tabular view of DE genes for postnatal day 4 - sub-clusters

```{r}

de.markers.sub[[1]] %>% 
  mutate(cluster = paste0("cluster_", cluster), 
         p_val_adj = format(p_val_adj, digits = 3), 
         p_val = format(p_val, digits = 3), 
         avg_log2FC = format(avg_log2FC, digits = 3)) %>%
  DT::datatable()

```

### Postnatal day 11 DEA - sub-clusters
***

```{r fig.width=11, fig.height=15}

DoHeatmap(se.filtered.split.bone[[2]], features = de.markers.sub[[2]] %>% 
          group_by(cluster) %>% 
          filter(p_val_adj < 0.01) %>%
          slice_head(n = 10) %>% 
          pull(gene))

```

Tabular view of DE genes for postnatal day 4 - sub-clusters

```{r}

de.markers.sub[[2]] %>% 
  mutate(cluster = paste0("cluster_", cluster), 
         p_val_adj = format(p_val_adj, digits = 3), 
         p_val = format(p_val, digits = 3), 
         avg_log2FC = format(avg_log2FC, digits = 3)) %>%
  DT::datatable()

```
 
### Notes
***

One issues with the clustering approach, in contrast to NNMF, is that the data is still convoluted. It's for example harder to tell if a cluster consists of a single cell type or multiple and it can also be hard to appreciate heterogeneity within clusters. 

For example, if we plot the cell cycle scores for the postnatal day 4 tissue data, we can see that cluster 4 has much higher scores and probably consist of more proliferating cells. However, there is probably no clear separation between cluster 4 and cluster 3, where we also see elevated scores. 

This is probably obvious to you, but good to keep in mind!

```{r fig.width=9, fig.height=4}

VlnPlot(se.filtered.split.bone[[1]], features = c("S.Score", "G2M.Score"))

```


```{r eval=FALSE, include=FALSE}

saveRDS(de.markers, file = "R_objects/de.markers")
saveRDS(de.markers.sub, file = "R_objects/de.markers.sub")
saveRDS(de.markers.all.data, file = "R_objects/de.markers.all.data")
saveRDS(de.markers.all.data.bone, file = "R_objects/de.markers.all.data.bone")
saveRDS(de.markers.all.data.bone.annotations, file = "R_objects/de.markers.all.data.bone.annotations")
saveRDS(object = se, file = "R_objects/mBone_Seurat_object_raw")
saveRDS(object = se.filtered, file = "R_objects/mBone_Seurat_object_filtered")
saveRDS(object = se.filtered.bone, file = "R_objects/mBone_Seurat_object_filtered_bone")
saveRDS(object = se.filtered.split, file = "R_objects/mBone_Seurat_object_filtered_list")
saveRDS(se.filtered.split.bone, "R_objects/mBone_Seurat_object_filtered_list_bone")

```



# Date
***

```{r}
date()
```

# Session
***

```{r}
devtools::session_info()
```


